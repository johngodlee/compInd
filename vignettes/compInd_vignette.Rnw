\documentclass{article}

% Define page geometry
\usepackage{geometry}
\geometry{left=2.2cm,
	right=2.2cm,
	top=2.2cm,
	bottom=2cm}
\parskip 0.15cm
\setlength{\parindent}{0cm}
\setlength{\parskip}{1em}

% Set font
\usepackage[T1]{fontenc}
\usepackage{xcolor}
\definecolor{midnightgreen}{rgb}{0.0, 0.29, 0.33}
\let\oldtexttt\texttt
\renewcommand\texttt[1]{{\ttfamily\color{midnightgreen}#1}}

% English language
\usepackage[UKenglish]{babel}
\usepackage{csquotes}

% Image handling
\usepackage{graphicx}  % Extended image support

\makeatletter
	\g@addto@macro\@floatboxreset\centering  % Automatically centre images (floats)
\makeatother

\usepackage{float}  %  Graphics placement [H] [H!] arguments

% Text formatting
\usepackage{url} % Allow nice formatting of URLs in text

\usepackage{enumerate}  % Enumerated lists

\usepackage{siunitx}
\usepackage{amsmath}

\usepackage[htt]{hyphenat}

% Bibliography management
\usepackage[style=authoryear, natbib=true, backend=biber]{biblatex}
\addbibresource{compInd_vignette.bib}

% Custom title formatting
\let\oldtitle\title

\renewcommand{\title}[1]{\oldtitle{\vspace{-1.5cm}#1}}

\usepackage[breaklinks]{hyperref}
\definecolor{links}{RGB}{191,59,72}
\hypersetup{
	breaklinks,
	colorlinks,
	allcolors=links,
	linktoc=section,
	pdfauthor={John L. Godlee}
}

\def\subsectionautorefname{section}
\def\subsubsectionautorefname{section}

\title{compInd package vignette}
\author{John L. Godlee}

\begin{document}

\maketitle{}

\texttt{compInd} is a collection of spatially explicit competition and diversity indices taken primarily from the forestry literature. The aim of the package is to provide these functions in a consistent framework and to provide convenience functions to prepare data for analysis. This document provides some basic usage of \texttt{compInd}, and describes the behaviour of some of the competition indices included as functions in the package. See the manual for the package for more information on each function, including references and equations.

<<setup, echo=FALSE>>=
knitr::knit_hooks$set(document = function(x) {
	sub('\\usepackage[]{color}', 
		'\\usepackage[table]{xcolor}', x, fixed = TRUE)})
knitr::opts_chunk$set(
  # eval=FALSE,
  cache=FALSE, 
  warning=FALSE, 
  message=FALSE,
  fig.pos="H",
  fig.align="center"
)

options(width=60, 
	continue="  ")

set.seed(000462)
@

<<pkg, message=FALSE>>=
library(compInd)

library(sf)
library(dplyr)
library(tidyr)
library(ggplot2)
library(patchwork)
library(viridis)
library(parallel)
@

Generate example plot data suited to spatial competition indices:

<<>>=
dat <- dataGen()
@

Randomly located individuals within 1 ha (100x100 m) plots:

<<>>=
ggplot() + 
  geom_point(data = dat, 
    aes(x = x, y = y, fill = species, size = diam),
    shape = 21) + 
  facet_wrap(~plot_id) + 
  theme(legend.position = "none") + 
  coord_equal()
@

\begin{figure}[H]
\centering
	\includegraphics[width=\textwidth]{dat_plot}
	\caption{Five plots with randomly located stems of different species.}
	\label{dat_plot}
\end{figure}


There is also a real-world example of a 1 ha woodland plot in Bicuar National Park, southwest Angola:

<<>>=
data(bicuar)

ggplot() + 
  geom_point(data = bicuar, 
    aes(x = x, y = y, fill = species, size = diam),
    shape = 21) + 
  theme(legend.position = "none") + 
  coord_equal()
@

Generate some extra columns, like basal area from stem diameter:

<<>>=
dat$ba <- basalArea(dat$diam)
@

Many of the functions in \texttt{compInd} are calculated for each individual in the structural unit (normally a plot), based on the individuals in their local neighbourhood. \texttt{nearNeighb()} provides multiple methods of identifying neighbours around focal individuals, returning a list of dataframes, one per focal individual, with the spatial relationships between the focal individual and each neighbour. The example below first splits the example data by plot ID, then feeds the data plot by plot to \texttt{nearNeighb()}, extracting the 4 nearest neighbours to each individual in the plot. After that, it adds some extra information to each focal and neighbour individual such as the species, diameter and spatial coordinates.

<<>>=
# Split data into list of plots
dat_split <- split(dat, dat$plot_id)

# For each plot
dat_neighb <- lapply(dat_split, function(x) {
  # Calculate nearest neighbours 
  neighb <- nearNeighb(x[,c("x", "y")], k = 4)
  
  # Add auxiliary information
  out <- lapply(neighb, function(y) {
    # For each focal individual
    focal_df <- x[y$focal,] 
    names(focal_df) <- c("plot_id", "focal_stem_id", 
      "focal_x", "focal_y", "focal_species", "focal_diam")

    # For each neighbour
    nb_df <- x[y$nb, -which(names(x) == "plot_id")]
    names(nb_df) <- c("nb_stem_id", 
      "nb_x", "nb_y", "nb_species", "nb_diam")
    
    # Combine dataframes
    do.call(cbind, list(y, focal_df, nb_df))
  })
  return(out)
})
@

Now it's possible to test various functions in \texttt{compInd}. The following functions act on each focal individual separately:

\begin{itemize}
	\item{\texttt{alemdag()}}
	\item{\texttt{baLarger()}}
	\item{\texttt{baLocal()}}
	\item{\texttt{crowdInd()}}
	\item{\texttt{dbhCorr()}}
	\item{\texttt{dbhDiff()}}
	\item{\texttt{dbhDom()}}
	\item{\texttt{hegyi()}}
	\item{\texttt{lorimerComp()}}
	\item{\texttt{martinEk()}}
	\item{\texttt{pointDens()}}
	\item{\texttt{domConInd()}}
\end{itemize}

Using \texttt{alemdag()} as an example, calculate the value of the Alemdag's tree competition index for each individual in each plot, using four neighbours as per convention:

<<>>=
# For each plot
alemdag_list <- lapply(dat_neighb, function(x) {
  # For each individual
  unlist(lapply(x, function(y) {
    # Calculate competition index
    alemdag(y$nb_diam, y$nb_dist, unique(y$focal_diam))
  }))
})
@

To use the other functions listed above, just switch the function name and particular arguments in place of \texttt{alemdag()}. To scale up to a whole plot, either the sum or mean of values from focal individuals is commonly used, depending on the competition index. It can also be informative to look at the distribution of values by calculating the standard deviation.

Other functions for competition indices, those which don't rely on a zone of competition, act on each structural unit (normally a plot), separately. These functions are:

\begin{itemize}
	\item{\texttt{clarkEvans()}}
	\item{\texttt{pielou()}}
	\item{\texttt{spatialMingling()}}
	\item{\texttt{winkelmass()}}
\end{itemize}

Using \texttt{clarkEvans()} as an example, calculate the value of the Clark-Evans index for each individual in the plot:

<<>>=
# For each plot
clarkEvans_list <- lapply(dat_split, function(x) {
  # Calculate competition index
  clarkEvans(x[,c("x", "y")], area = 10000)
})
@

There are some extra convenience functions in \texttt{compInd} to make it easier to prepare data for the competition index calculations. The first, \texttt{nearNeighb()} has already been explained above. 

\texttt{lorimerCZR()} can be used to estimate the competition zone radius for a structural unit based on the number of individuals in the unit. The output of \texttt{lorimerCZR()} could then be fed to either \texttt{nearNeighb()} as the \texttt{radius} argument, or to \texttt{lorimerComp()}, which uses this value to normalise the result of the competition index for comparison among units with different individual densities.

<<>>=
lorimerCZR(k = 1, nrow(bicuar))
@

\texttt{edgeExclude()} can be used to find individuals that are sufficiently distant from the edge of a plot. For competition indices which rely on a competition zone radius such as \texttt{lorimerComp()}, \texttt{alemdag()} etc, individuals near the edges of the plot will erroneously under-estimate competition compared to other individuals in the plot interior, because individuals outside the plot are not recorded. It is common practice to exclude focal individuals if they are located a distance from the plot edge that is less than the radius of the competition zone. These individuals could still be used as competitors for other focal individuals, but not as focal individuals themselves. 

Consider the plots below, which show the effect of a buffer of 10 m radius in causing under-estimations of competition calculated by \texttt{crowdInd()}:

<<>>=
# Generate data for one plot, 500 stems
dat <- dataGen(nplots = 1, min_stems = 500, max_stems = 500)

# Find nearest neighbours for each individual
neighb_rad10 <- nearNeighb(dat[,c("x", "y")], radius = 10)

# Count number of neighbours identified
dat$n_neighb <- unlist(lapply(neighb_rad10, nrow))

# Create a map of individuals, coloured and sized by number of neighbours
ggplot() + 
  geom_point(data = dat, 
    aes(x = x, y = y, size = n_neighb, colour = n_neighb)) + 
  scale_colour_viridis()
@

<<>>=
# Find if an individual is in the edge of a plot
dat$edge <- "OUT"
dat$edge[edgeExclude(dat[,c("x", "y")], 10, 0, 100, 0, 100)] <- "IN"

# Create boxplot
ggplot() + 
  geom_boxplot(data = dat, 
    aes(x = edge, y = n_neighb, colour = edge))
@

<<>>=
# Create buffers around individuals to illustrate competition zone radius
dat_buffer <- st_as_sf(dat, coords = c("x", "y")) %>%
  st_buffer(., 10)

# Map of buffer radii, coloured by if individual is in the edge of the plot
ggplot() + 
  geom_sf(data = dat_buffer, aes(colour = edge), fill = NA) + 
  geom_point(data = dat, aes(x = x, y = y)) 
@

The various competition indices in \texttt{compInd} behave in subtly different ways as the number of individuals, species, neighbours or their spatial distribution changes. Below we produce visualisations of various indices under different conditions.

Generate data with increasing abundance:

<<>>=
ab_vec <- rep(seq(50,550, 100), 10)
ab_list <- lapply(ab_vec, function(x) {
  out <- dataGen(nplots = 1, min_stems = x, max_stems = x, 
    species = LETTERS[1:10])
  out$plot_id <- as.character(x)
  out$ba <- basalArea(out$diam)
  return(out)
})

ggplot() + 
  geom_point(data = do.call(rbind, ab_list[seq(1,20,2)]), 
    aes(x = x, y = y, fill = species),
    shape = 21) + 
  facet_wrap(~as.numeric(plot_id)) + 
  theme_bw() + 
  theme(legend.position = "none") + 
  coord_equal()
@

Calculate nearest neighbours for each sample:

<<>>=
ab_neighb <- mclapply(ab_list, function(x) {
  neighb <- nearNeighb(x[,c("x", "y")], k = 4)
  out <- lapply(neighb, function(y) {
    focal_df <- x[y$focal,] 
    names(focal_df) <- c("plot_id", "focal_stem_id", 
      "focal_x", "focal_y", "focal_species", "focal_diam", "focal_ba")

    nb_df <- x[y$nb, -which(names(x) == "plot_id")]
    names(nb_df) <- c("nb_stem_id", 
      "nb_x", "nb_y", "nb_species", "nb_diam", "nb_ba")
    
    do.call(cbind, list(y, focal_df, nb_df))
  })
  return(out)
}, mc.cores = detectCores())
@

Calculate plot level values for various indices: 

<<>>=
ab_summ <- do.call(rbind, mclapply(seq_along(ab_neighb), function(x) {
  xdf <- ab_list[[x]]
  plot_id <- xdf$plot_id[1]

  # Calculate plot-level indices
  ab_lorimerCZR <- lorimerCZR(1, nrow(xdf)) 
  ab_clarkEvans <- clarkEvans(xdf[,c("x", "y")], 10000)
  ab_pielou_mean <- mean(pielou(xdf[,c("x", "y")], 0, 100, 0, 100, 20))
  ab_spatialMingling_mean <- mean(spatialMingling(
  		  xdf[,c("x", "y")], xdf$species))
  ab_winkelmass_mean <- mean(winkelmass(xdf[,c("x", "y")], 4))

  # Calculate individual-level indices
  out <- do.call(rbind, lapply(ab_neighb[[x]], function(y) {
    data.frame(
      ab_alemdag = alemdag(y$nb_diam, y$nb_dist, unique(y$focal_diam)),
      ab_baLarger = baLarger(y$nb_ba, unique(y$focal_ba), y$nb_ba),
      ab_baLocal = baLocal(y$nb_ba),
      ab_crowdInd = crowdInd(y$nb_diam),
      ab_dbhCorr = dbhCorr(y$nb_diam, unique(y$focal_diam)),
      ab_dbhDiff = dbhDiff(y$nb_diam, unique(y$focal_diam)),
      ab_dbhDom = dbhDom(y$nb_diam, unique(y$focal_diam)),
      ab_hegyi = hegyi(y$nb_diam, y$nb_dist, unique(y$focal_diam)),
      ab_lorimerComp = lorimerComp(y$nb_diam, y$nb_dist, unique(y$focal_diam), ab_lorimerCZR),
      ab_martinEk = martinEk(y$nb_diam, y$nb_dist, unique(y$focal_diam)),
      ab_pointDens = pointDens(y$nb_diam, y$nb_dist)
    )
  }))

  out_summ <- out %>%
    summarise(
      ab_alemdag_mean = mean(ab_alemdag),
      ab_baLarger_sum = sum(ab_baLarger),
      ab_baLocal_sum = sum(ab_baLocal),
      ab_crowdInd_mean = mean(ab_crowdInd),
      ab_dbhCorr_mean = mean(ab_dbhCorr),
      ab_dbhDiff_mean = mean(ab_dbhDiff),
      ab_dbhDom_mean = mean(ab_dbhDom),
      ab_hegyi_mean = mean(ab_hegyi),
      ab_lorimerComp_mean = mean(ab_lorimerComp),
      ab_martinEk_mean = mean(ab_martinEk),
      ab_pointDens_mean = mean(ab_pointDens)
    ) %>%
    mutate(
      plot_id = plot_id,
      ab_lorimerCZR = ab_lorimerCZR,
      ab_clarkEvans = ab_clarkEvans,
      ab_pielou_mean = ab_pielou_mean,
      ab_spatialMingling_mean = ab_spatialMingling_mean,
      ab_winkelmass_mean = ab_winkelmass_mean
    )

  return(out_summ)
}, mc.cores = detectCores()))
@

Plot variation in indices with varying abundance:

<<>>=
ab_summ_long <- ab_summ %>%
  pivot_longer(-plot_id)

ggplot() + 
  geom_point(data = ab_summ_long, aes(x = as.numeric(plot_id), y = value),
    fill = "darkgrey", shape = 21) + 
  geom_smooth(data = ab_summ_long, aes(x = as.numeric(plot_id), y = value), 
    method = "loess") + 
  facet_wrap(~name, scales = "free") + 
  theme_bw() + 
  labs(x = "N stems", y = "")
@

The number of neighbours considered by \texttt{nearNeighb()} also affects the behaviour of the indices:

<<>>=
# Define vector of increasing number of neighbours 
k_vec <- seq(1, 12, 1)

# Using a dataset with randomly located individuals 
datr <- ab_list[[length(ab_list)]]

# Calculate nearest neighbours using maximum k
nb <- nearNeighb(datr[,c("x", "y")], k = max(k_vec))

nb_all <- lapply(nb, function(x) { 
	focal_df <- datr[x$focal,] 
	names(focal_df) <- c("plot_id", "focal_stem_id", 
	  "focal_x", "focal_y", "focal_species", "focal_diam", "focal_ba")

	nb_df <- datr[x$nb, -which(names(datr) == "plot_id")]
	names(nb_df) <- c("nb_stem_id", 
	  "nb_x", "nb_y", "nb_species", "nb_diam", "nb_ba")

	do.call(cbind, list(x, focal_df, nb_df))
	})

# For each k
k_summ <- do.call(rbind, mclapply(k_vec, function(x) {
  # For each individual
  do.call(rbind, lapply(nb_all, function(y) {
	  out <- data.frame(
		ab_alemdag = alemdag(y$nb_diam[1:x], y$nb_dist[1:x], y$focal_diam[1]),
		ab_baLarger = baLarger(y$nb_ba, y$focal_ba[1], y$nb_ba),
		ab_baLocal = baLocal(y$nb_ba),
		ab_crowdInd = crowdInd(y$nb_diam[1:x]),
		ab_dbhCorr = dbhCorr(y$nb_diam[1:x], y$focal_diam[1]),
		ab_dbhDiff = dbhDiff(y$nb_diam[1:x], y$focal_diam[1]),
		ab_dbhDom = dbhDom(y$nb_diam[1:x], y$focal_diam[1]),
		ab_hegyi = hegyi(y$nb_diam[1:x], y$nb_dist[1:x], y$focal_diam[1]),
		ab_martinEk = martinEk(y$nb_diam[1:x], y$nb_dist[1:x], y$focal_diam[1]),
		ab_pointDens = pointDens(y$nb_diam[1:x], y$nb_dist[1:x])
	  )

	  out_summ <- out %>%
	    summarise(
          ab_alemdag_mean = mean(ab_alemdag),
          ab_baLarger_sum = sum(ab_baLarger),
          ab_baLocal_sum = sum(ab_baLocal),
          ab_crowdInd_mean = mean(ab_crowdInd),
          ab_dbhCorr_mean = mean(ab_dbhCorr),
          ab_dbhDiff_mean = mean(ab_dbhDiff),
          ab_dbhDom_mean = mean(ab_dbhDom),
          ab_hegyi_mean = mean(ab_hegyi),
          ab_martinEk_mean = mean(ab_martinEk),
          ab_pointDens_mean = mean(ab_pointDens)) %>%
        mutate(k = x) 

    return(out_summ)
  }))
}, mc.cores = detectCores()))
@

<<>>=
# TODO:
k_summ_long <- k_summ %>% 
  pivot_longer(-k)

ggplot() + 
  geom_point(data = k_summ_long, aes(x = as.numeric(k), y = value),
    fill = "darkgrey", shape = 21) + 
  geom_smooth(data = k_summ_long, aes(x = as.numeric(k), y = value), 
    method = "loess") + 
  facet_wrap(~name, scales = "free") + 
  theme_bw() + 
  labs(x = "k", y = "")
@

Variation in the number of species affects \texttt{spatialMingling()}:

<<>>=
# Variation in number of species
sp <- paste0(
  rep(LETTERS, each = 26),
  rep(letters, times = 26))
sp_vec <- rep(seq(1,50,1), 10)
sp_list <- lapply(sp_vec, function(x) {
  out <- dataGen(nplots = 1, min_stems = 100, max_stems = 100, species = sp[1:x])
  out$plot_id <- as.character(x)
  out$ba <- basalArea(out$diam)
  return(out)
})

sp_spatialMingling_list <- unlist(lapply(sp_list, function(x) {
  mean(spatialMingling(x[,c("x", "y")], x$species))
}))

ggplot() + 
  geom_point(aes(x = sp_vec, y = sp_spatialMingling_list),
    shape = 21, fill = "darkgrey") + 
  theme_bw() + 
  labs(x = "N species", y = expression(bar(M[i])))
@

As does variation in the spatial mixing of species, which is what \texttt{spatialMingling()} is designed to detect:

<<>>=
# Increasing mixing of species

# Choose 9 species
mi_n_sp <- 9
sp_vec <- LETTERS[1:mi_n_sp]

# Create squares
xy_vec <- seq(0.5,3, 0.5)
dat <- expand.grid(xy_vec, xy_vec)

dat_list <- lapply(sp_vec, function(x) {
  dat$sp <- x
  return(dat)
    })

adj_list <- expand.grid(c(0,3,6), c(0,3,6))

grid_df <- do.call(rbind, lapply(seq_along(dat_list), function(x) {
  dat_list[[x]]$Var1 <- dat_list[[x]]$Var1 + adj_list[x,1]
  dat_list[[x]]$Var2 <- dat_list[[x]]$Var2 + adj_list[x,2]

  return(dat_list[[x]])
    }))

mi_n_reps <- 100
repl_list <- replicate(mi_n_reps, grid_df, simplify = FALSE)
repl_list <- lapply(repl_list, function(x) {
  x$adj <- 0
  x
    })
repl_list <- list(repl_list)

for (i in seq_len(1000)) {
  repl_list[[i + 1]] <- repl_list[[i]]
  repl_list[[i + 1]] <- lapply(repl_list[[i + 1]], function(x) {
    repls <- sample(seq_len(nrow(grid_df)), 2)
    repl_a <- x$sp[repls[1]]
    repl_b <- x$sp[repls[2]]
    x$sp[repls[1]] <- repl_b
    x$sp[repls[2]] <- repl_a
    x$adj <- i
    x
  })
}

mi_repl_df <- do.call(rbind, mclapply(repl_list, function(x) {
  do.call(rbind, lapply(x, function(y) {
    data.frame(
      adj = y$adj[1],
      spm = mean(spatialMingling(y[,c("Var1", "Var2")], y$sp, 
        k = 4, adj = TRUE))
      )
  }))
  }, mc.cores = detectCores()))

mi_repl_df_g <- mi_repl_df %>%
  group_by(adj) %>%
  mutate(run = as.character(row_number()))

ggplot() + 
  geom_line(data = mi_repl_df_g, 
    aes(x = adj, y = spm, group = run), alpha = 0.5) + 
  theme_bw() + 
  labs(x = "N substitutions", y = expression(bar(M[i])))
@

The winkelmass measures the spatial regularity of individuals. The plots below show how the winkelmass varies with increasingly random individual location:

<<>>=
xy_vec <- seq(2,50, 4)
dat <- expand.grid(xy_vec, xy_vec)
names(dat) <- c("x", "y")

wi_reps <- 20
wi_list <- replicate(20, dat, simplify = FALSE)
wi_list <- lapply(wi_list, function(x) {
  x$adj <- 0
  x
    })
wi_list <- list(wi_list)

coord_repls <- seq(0,50,0.1)

for (i in seq_len(200)) {
  wi_list[[i + 1]] <- wi_list[[i]]
  wi_list[[i + 1]] <- lapply(wi_list[[i + 1]], function(x) {
    x[sample(nrow(x), 1),c(1,2)] <- sample(coord_repls, 2)
    x$adj <- i
    x
  })
}
@

<<>>=
wi_df <- do.call(rbind, mclapply(wi_list, function(x) {
  do.call(rbind, lapply(x, function(y) {
    data.frame(
      adj = y$adj[1],
      wi = mean(winkelmass(y$x, y$y, k = 4))
      )
    }))
  }, mc.cores = detectCores()))

wi_df_clean <- wi_df %>%
  group_by(adj) %>%
  mutate(run = row_number())

wi_samples <- c(0,50,100,150,200)

wi_plot <- ggplot() + 
  geom_line(data = wi_df_clean, 
    aes(x = adj, y = wi, group = run)) + 
  geom_vline(xintercept = wi_samples, 
    colour = "red", linetype = 2) + 
  theme_bw() + 
  labs(x = "N substitutions", y = expression(bar(W[i]))) + 
  theme(legend.position = "bottom") 

wi_df_fil <- do.call(rbind, 
  lapply(wi_list[wi_samples + 1], "[[", 1)) %>%
  mutate(adj = paste0("N = ", adj)) %>%
  mutate(adj = factor(adj, levels = paste0("N = ", wi_samples))) 

wi_map_plot <- ggplot() + 
  geom_point(data = wi_df_fil, 
    aes(x = x, y = y),
    fill = "darkgrey", shape = 21) + 
  facet_wrap(~adj, nrow = 1) + 
  theme_bw() + 
  theme(
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "none") + 
  labs(x = "X", y = "Y") + 
  coord_equal()

wi_plot + wi_map_plot + 
  plot_layout(ncol = 1, heights = c(2,1))
@

\end{document}
